---
jupytext:
  formats: ipynb,md:myst
  text_representation:
    extension: .md
    format_name: myst
    format_version: 0.13
    jupytext_version: 1.16.0
kernelspec:
  display_name: Python 3 (ipykernel)
  language: python
  name: python3
---

# Bayesian Inference using two ELF datasets with different wavenumbers

Similar to 5.4 but uses the absolute residual

```{code-cell} ipython3
# Load the "autoreload" extension so that code can change
%load_ext autoreload

# always reload modules so that as you change code in src, it gets loaded
%autoreload 2
```

```{code-cell} ipython3
import numpy as np
rng = np.random.default_rng()
import matplotlib.pyplot as plt
from scipy import optimize
from datetime import datetime

import emcee 
from uegdielectric import ElectronGas
from uegdielectric.dielectric import Mermin

from src.inference.collision_models import collision_activate_decay, collision_activate_decay_imag
from src.inference.mcmc_inference import inference_loop, flat_mcmc_samples
from src.utilities import AtomicUnits, elec_loss_fn
import src.inference.probability_models as prob

import warnings
warnings.filterwarnings('ignore')
```

# Get the average-atom data

```{code-cell} ipython3
datafile = "../../data/external/Al-1 _vwf.txt"
# just copying from the data file
# temperature
teV = 1
t = teV / AtomicUnits.energy

# density
d_ang = 0.18071 # 1/[angstroms]**3
d = d_ang * AtomicUnits.length**3

# chemical potential
cp = 0.3212 # [at u]

datadump = np.loadtxt(datafile, skiprows=9, usecols=[0, 5, 6, 9], unpack=True)
orig_freq_data = datadump[0] # [eV]
print(f"length of original data = {len(orig_freq_data)}")
AA_collfreq_data = datadump[1] + 1j * datadump[2]
dos_data = datadump[3]

# function for Average Atom collision freq
AA_collfreq_fn = lambda x : np.interp(x, orig_freq_data / AtomicUnits.energy, AA_collfreq_data)
# function for DOS ratio
dos_fn = lambda x : np.interp(x, np.sqrt(2 * orig_freq_data / AtomicUnits.energy), dos_data)

# electron data
electrons = ElectronGas(t, d, dos_fn, cp)

# dielectric function
dielectric = Mermin(electrons)

# create a new, more regular frequency grid that what exists in the data file
freq_data = np.geomspace(1e-1, 1e3, 200) # [eV]
# Wavenumber is independent of data -- can pick whatever we want to create our ELF data
wavenum = np.asarray([1.55,  4.39]) # 1/[angstrom]
```

# Define collision frequency model

```{code-cell} ipython3
# define our collision frequency function
def collisionfreq(freq, params):
    # real part
    recollision = collision_activate_decay(freq, *params)
    # imaginary part
    imcollision = collision_activate_decay_imag(freq, *params)

    return recollision + 1j * imcollision
```

# Define the ELF model

using the Mermin dielectric function and the `collisionfreq` function

```{code-cell} ipython3
def elfmodel(freq, params):
    return elec_loss_fn(
        dielectric,
        wavenum * AtomicUnits.length,
        freq,
        lambda x: collisionfreq(x, params)
    )
```

## Collision frequency parameters that mimic average atom data

Taken from other notebooks.

```{code-cell} ipython3
# fit to data
popt_AAcoll = np.asarray([0.48647414, 0.06293753, 0.27164363, 8.66461154])
print(popt_AAcoll)

# plot to compare
plt.semilogx(freq_data, (AAcoll := AA_collfreq_fn(freq_data / AtomicUnits.energy)).real, c="C3", label="AA")
plt.plot(freq_data, AAcoll.imag, c="C3", ls="--")
plt.plot(freq_data, (modelcoll := collisionfreq(freq_data / AtomicUnits.energy, popt_AAcoll)).real, c="C0", label="opt")
plt.plot(freq_data, modelcoll.imag, c="C0", ls="--")
plt.xlabel(r"$\hbar\omega$ [eV]")
plt.ylabel("collision freq [au]")
plt.legend()
```

### Create ELF data with our collision frequency  model using the optimized parameters fit to mimic the average-atom collision frequency data

```{code-cell} ipython3
# true ELF data
elf_data = elfmodel(freq_data / AtomicUnits.energy, popt_AAcoll)
print(f"shape of ELF data = {elf_data.shape}")
```

# Define residual function for ELF data

Do a least squares fit of the ELF model to the ELF data by varying the parameters of the collision frequency model. This fit should be pretty close since the data is generated by the model being fit.

```{code-cell} ipython3
# setup
def residual(params):
    return prob.residual(
        elfmodel, freq_data / AtomicUnits.energy, elf_data, params, type="abs"
    )

# initial parameter guesses
initparams = (1, 1, 1, 1)

# optimization results
optresult = optimize.least_squares(residual, initparams, bounds=(0, np.inf), max_nfev=150)
```

```{code-cell} ipython3
optresult
```

```{code-cell} ipython3
# original
plt.semilogx(freq_data, collisionfreq(freq_data / AtomicUnits.energy, popt_AAcoll).real, c="C3", label="true")
# optimized
plt.plot(freq_data, collisionfreq(freq_data / AtomicUnits.energy, optresult.x).real, c="C0", label="opt.", ls="--")
plt.xlabel(r"$\hbar\omega$ [eV]")
plt.ylabel("collision freq [au]")
plt.legend()
```

```{code-cell} ipython3
plt.loglog(freq_data, elf_data[0], label="true: q1", color="C3")
plt.loglog(freq_data, elf_data[1], label="true: q2", color="C1")
opt_elf = elfmodel(freq_data / AtomicUnits.energy, optresult.x)
plt.plot(freq_data, opt_elf[0], ls='-.', label="opt.: q1", color="C0")
plt.plot(freq_data, opt_elf[1], ls='-.', label="opt.: q2", color="C2")
plt.ylabel("ELF [au]")
plt.xlabel(r"$\hbar \omega$ [eV]")
plt.ylim(1e-6)
plt.legend()
```

# Perform MCMC

Define a (log) posterior distribution that only depends on the parameters of the collision frequency model

```{code-cell} ipython3
lik_cutoff = 0.05
prior_lims = [
    [0, 5],
    [0, 5],
    [0, 100],
    [0, 100]
]

logprior = prob.UniformLogPrior(prior_lims)
loglikelihood = prob.SoftCutoffLogLikelihood(
    elf_data,
    freq_data / AtomicUnits.energy,
    elfmodel,
    lik_cutoff,
    residualtype="abs"
)
logposterior = prob.LogPosterior(logprior, loglikelihood)
logposterior(optresult.x)
```

## Run the MCMC sampler

We will use the results from the optimization to initialize the Markov chains.

```{code-cell} ipython3
samplesfile = "../../data/mcmc/mcmc_twoangle"
dataset = "absolute residual"
```

```{code-cell} ipython3
runinfo = {
    "date" : datetime.today().strftime('%a %d %b %Y, %I:%M%p'),
    "input data info" : f"""Data generated using Average Atom 
         collisions [T-matrix cross sections, nonideal DOS, QOZ structure
         factors, LB form, inelastic processes], from file {datafile}. Uses adaptive
         Kramers-Kronig transform for imaginary part of collision freq.""",
    "input data temperature [eV]" : teV,
    "input data density [1/angstrom^3]" : d_ang,
    "input data wavenumber [1/angstrom]" : wavenum,
    "frequency grid [eV]" : freq_data,
    "collision freq model" : "collision_activate_decay, 4 parameter",
    "likelihood function" : f"Soft (expenonential) cutoff with a cutoff value of {lik_cutoff}",
    "residual" : "absolute",
    "prior distribution function" : f"Uniform distribution with boundaries ({prior_lims})"
}

# sampler properties
ndim = 4 # number of parameters
numchains = 8
numsamples = 1_000
```

```{code-cell} ipython3
# randomly initialize chains within the boundaries
initial_state = optresult.x + 1e-4 * rng.random(size=(numchains, ndim))

# uncomment to run and potentially overwrite data
sampler = inference_loop(initial_state, logposterior, numsamples, samplesfile, dataset, overwrite=False)
```

```{code-cell} ipython3
# # view attributes of dataset
# with h5py.File(samplesfile, "a") as f:
#     print(list(f.keys()))
#     dset = f["mcmc_samples"]
#     for attr in dset.attrs:
#         print(f"{attr} : {dset.attrs[attr]}")
```

# Read in MCMC data

```{code-cell} ipython3
backend = emcee.backends.HDFBackend(samplesfile, name=dataset)
flat_samples = flat_mcmc_samples(backend)
```

# MCMC results

## Markov chain tracings for each parameter

Note there are multiple chains being plotted for each parameter, showing their paths in the 4D parameter space.

```{code-cell} ipython3
plt.close()
paramnames = (
    "gen. Lorentzian height",
    "gen. Lorentzian power-law",
    "Logistic activate",
    "Logistic gradient"
)
fig, axes = plt.subplots(ndim, figsize=(10,2.5*5), sharex=True)
samples = backend.get_chain()
for i in range(ndim):
    ax = axes[i]
    ax.plot(samples[:,:,i], 'k', alpha=0.3)
    #ax.set_xlim(0, len(samples))
    ax.set_ylabel(f"{paramnames[i]}")
    ax.yaxis.set_label_coords(-0.1, 0.5)

axes[-1].set_xlabel("step number");
```

## Corner plot showing histograms of the samples from the posterior distribution

The posterior is 4-dimensional (4 parameters), but the corner plot shows 1D and 2D slices through the full distribution (i.e. marginal distributions). The blue-dashed line shows the mean of the samples and the red line shows the true parameter values.

```{code-cell} ipython3
import corner

fig = corner.corner(flat_samples, labels=paramnames)

# compute empirical mean of samples
mean = np.mean(flat_samples, axis=0)

corner.overplot_lines(fig, mean, linestyle="--", color="C0")
corner.overplot_points(fig, mean[np.newaxis], marker="o", linestyle="--", color="C0")
corner.overplot_lines(fig, popt_AAcoll, color="C3")
corner.overplot_points(fig, popt_AAcoll[np.newaxis], marker="o", color="C3")
```

## Plot the collision frequency model using random samples of the parameters from MCMC

```{code-cell} ipython3
# randomly pick 100 samples from our MCMC sampling data
inds = rng.integers(len(flat_samples), size=100)

# plot collision function for different parameters from MCMC sampling
for ind in inds:
    sample = flat_samples[ind]
    plt.semilogx(
        freq_data, 
        collisionfreq(freq_data / AtomicUnits.energy, sample), 
        "C1", 
        alpha=0.1
    )

# plot true collision frequency
plt.plot(freq_data,
         collisionfreq(freq_data / AtomicUnits.energy, popt_AAcoll).real,
         c="k",
         label="true",
         lw=2,
         ls='--'
        )

plt.xlabel(r"$\hbar\omega$ [eV]")
plt.ylabel("collision freq [au]")
# plt.ylim(1e-3)
plt.legend()
# plt.savefig("../../reports/figures/mcmc_modeldata_collisionsamples")
```

## Plot the ELF model using random samples of the (collision frequency) parameters from MCMC

This uses the same random samples from the above plot.

```{code-cell} ipython3
# plot ELF for different parameters from MCMC sampling
for ind in inds:
    sample = flat_samples[ind]
    plt.loglog(
        freq_data,
        elfmodel(freq_data / AtomicUnits.energy, sample).T, 
        "C1", 
        alpha=0.1
    )
# plot data
plt.loglog(freq_data, elf_data[0], c="k", label="true ELF: q1", lw=2, ls='--')
plt.loglog(freq_data, elf_data[1], c="k", label="true ELF: q2", lw=2, ls='-.')

plt.ylabel("ELF [au]")
plt.xlabel(r"$\hbar\omega$ [eV]")
plt.ylim(1e-6)
plt.legend()
# plt.savefig("../../reports/figures/mcmc_modeldata_ELFsamples")
```

```{code-cell} ipython3
eps = Mermin(ElectronGas(t, d, dos_fn))
# plot ELF for different parameters from MCMC sampling
for ind in inds:
    sample = flat_samples[ind]
    plt.plot(
        freq_data,
        elfmodel(freq_data / AtomicUnits.energy, sample).T, 
        "C1", 
        alpha=0.1
    )
# plot data
plt.plot(freq_data, elf_data[0], c="k", label="true ELF: q1", lw=2, ls='--')
plt.plot(freq_data, elf_data[1], c="k", label="true ELF: q2", lw=2, ls='-.')

plt.ylabel("ELF [au]")
plt.xlabel(r"$\hbar\omega$ [eV]")
plt.xlim(0, 130)
plt.legend()
```

```{code-cell} ipython3

```

```{code-cell} ipython3

```
