---
jupytext:
  formats: ipynb,md:myst
  text_representation:
    extension: .md
    format_name: myst
    format_version: 0.13
    jupytext_version: 1.15.2
kernelspec:
  display_name: Python 3 (ipykernel)
  language: python
  name: python3
---

# Optimize collision rate model for known Average Atom collision rate data

We use collision rate data from an average atom model to produce Mermin ELF data.
We then try to fit a Mermin ELF model using our collision rate model to the data.
This is different from notebook `4.0-twh-optimize-known-collisions.txt` because 
the collision rate that produced the data comes from an independent/black-box 
collision rate model.

The goal with this notebook is to highlight the flexibility of our own collision
rate model.

```{code-cell} ipython3
# Load the "autoreload" extension so that code can change
%load_ext autoreload

# always reload modules so that as you change code in src, it gets loaded
%autoreload 2
```

```{code-cell} ipython3
import numpy as np
from scipy import optimize
import matplotlib.pyplot as plt

import json

from uegdielectric import ElectronGas
from uegdielectric.dielectric import Mermin

from src.inference.collision_models import collision_activate_decay
from src.inference.mcmc_inference import inference_loop
from src.utilities import collrateimag, AtomicUnits, elec_loss_fn
```

# Define collision rate model

```{code-cell} ipython3
# define our collision rate function
def collisionrate(freq, params):
    # real part
    recollision = collision_activate_decay(freq, **params)
    # imaginary part
    imcollision = collrateimag(recollision)

    return recollision + 1j * imcollision
```

# Get data

```{code-cell} ipython3
filename = "../../data/external/Al-1 _vwf.txt"
# just copying from the data file
# temperature
teV = 1
t = teV / AtomicUnits.energy

# density
d_ang = 0.18071 # 1/[angstroms]**3
d = d_ang * AtomicUnits.length**3

datadump = np.loadtxt(filename, skiprows=9, usecols=[0, 5, 6, 9], unpack=True)
freq_data = datadump[0] # [eV]
print(f"length of data = {len(freq_data)}")
collrate_data = datadump[1] + 1j * datadump[2]
dos_data = datadump[3]

# function for true collision rate
true_collrate_fn = lambda x : np.interp(x, freq_data / AtomicUnits.energy, collrate_data)
# function for DOS ratio
dos_fn = lambda x : np.interp(x, freq_data / AtomicUnits.energy, dos_data)

# Wavenumber is independent of data -- can pick whatever we want to create our ELF data
wavenum_val = 0.7 / AtomicUnits.length # 1/[angstrom]
```

### Create ELF data with collision rate data

We will also trim down the number of data points.

```{code-cell} ipython3
# Reduce the amount of data we are considering
freq_data_trim = freq_data[::8]

elf_data = elec_loss_fn(Mermin(ElectronGas(t, d, dos_fn)),
                        wavenum_val * AtomicUnits.length,
                        freq_data_trim / AtomicUnits.energy,
                        true_collrate_fn
                       )
print(elf_data.shape)
```

### plot the collision rate data

```{code-cell} ipython3
plt.semilogx(freq_data_trim, true_collrate_fn(freq_data_trim / AtomicUnits.energy).real, label="real")
plt.plot(freq_data_trim, true_collrate_fn(freq_data_trim / AtomicUnits.energy).imag, label="imag.")
plt.xlabel(r"$\omega$ [eV]")
plt.ylabel("collision frequency [au]")
plt.legend()
```

# Define residual function for optimizing the parameters

This is a first step before doing Bayesian inference

```{code-cell} ipython3
def residual_fn(x, y, dielectricfn, wavenum, collisionfn):
    """ 
    x: frequency data points corresponding to output data `y`
    y: ELF data points
    dielectricfn: dielectric function, a function of `wavenum` and `freq`
    wavenum: wave number value(s)
    freq: array of frequency values
    collisionfn: function for collision rate, depends on `freq` and `params`
    
    returns:
        residual function that only depends on params
    """
    def residual(params):
        """
        Residual function that only depends on parameters of collision rate model
        
        params (dict): parameters that go into collision rate model
        """
        elf_calc = elec_loss_fn(dielectricfn,
                                wavenum,
                                x,
                                lambda x: collisionfn(x, params))
        return y - elf_calc
        
    return residual
```

# Optimize to get initial guess for parameters

```{code-cell} ipython3
def dict_least_squares(fun, dict0, *args, **kwargs):
    """
    scipy.optimize.least_squares using a dictionary to hold parameters
    (scipy assumes a tuple or array)

    function from <https://stackoverflow.com/questions/70673646/passing-a-dictonary-to-scipy-optimize-least-squares>
    """
    keys = list(dict0.keys());
    result = optimize.least_squares(
        lambda x: fun({k:v for k,v in zip(keys, x)}), # wrap the argument in a dict
        [dict0[k] for k in keys], # unwrap the initial dictionary
        *args, # pass position arguments
        **kwargs # pass named arguments
    )
    # wrap the solution in a dictionary
    try:
        result.x = {k:v for k,v in zip(keys, result.x)}
    except:
        pass;
    return result;
    
```

```{code-cell} ipython3
# setup
residual = residual_fn(freq_data_trim / AtomicUnits.energy,
                       elf_data,
                       Mermin(ElectronGas(t, d, dos_fn)),
                       wavenum_val * AtomicUnits.length,
                       collisionrate
                      )
# initial parameter guesses
initparams = {"drude_center": 0, 
               "drude_height": 1, 
               "gendrude_center": 0, 
               "gendrude_height": 1, 
               "gendrude_decay": 1.5, 
               "logistic_activate": 0, 
               "logistic_gradient": 10
              }

# optimization results
optresult = dict_least_squares(residual, initparams, max_nfev=150)
```

```{code-cell} ipython3
optresult
```

Plot true collision frequencies and the optimized versions

```{code-cell} ipython3
# original
plt.semilogx(freq_data_trim, true_collrate_fn(freq_data_trim / AtomicUnits.energy).real, c="C3", label="Avg. Atom")
plt.plot(freq_data_trim, true_collrate_fn(freq_data_trim / AtomicUnits.energy).imag, c="C3", ls="--")
# optimized
plt.plot(freq_data_trim, collisionrate(freq_data_trim / AtomicUnits.energy, optresult.x).real, c="C0", label="opt.")
plt.plot(freq_data_trim, collisionrate(freq_data_trim / AtomicUnits.energy, optresult.x).imag, c="C0", ls="--")
plt.xlabel(r"$\omega$ [eV]")
plt.ylabel("collision frequency [au]")
plt.legend()
```

```{code-cell} ipython3
plt.semilogx(freq_data_trim, elf_data, c="C3", label="Avg. Atom")
opt_elf = elec_loss_fn(Mermin(ElectronGas(t, d, dos_fn)),
                       wavenum_val * AtomicUnits.length,
                       freq_data_trim / AtomicUnits.energy,
                       lambda x: collisionrate(x, optresult.x)
                      )
plt.plot(freq_data_trim, opt_elf, c="C0", ls='-.', label="opt.")
plt.ylabel("ELF [au]")
plt.xlabel(r"$\omega$ [eV]")
plt.ylim(1e-6) # resolution of data
plt.legend()
```

```{code-cell} ipython3
plt.loglog(freq_data_trim, elf_data, c="C3", label="Avg. Atom")
opt_elf = elec_loss_fn(Mermin(ElectronGas(t, d, dos_fn)),
                       wavenum_val * AtomicUnits.length,
                       freq_data_trim / AtomicUnits.energy,
                       lambda x: collisionrate(x, optresult.x)
                      )
plt.plot(freq_data_trim, opt_elf, c="C0", ls='-.', label="opt.")
plt.ylabel("ELF [au]")
plt.xlabel(r"$\omega$ [eV]")
plt.ylim(1e-6) # resolution of data
plt.legend()
```

# Perform MCMC

+++

Define our prior probability density function (pdf), likelihood, and posterior pdf

```{code-cell} ipython3
def log_prior(params, low=0, high=5):
    """
    Uniform prior pdf over parameters

    ERROR: Only a few parameters need to be strictly positive (like the heights)
    Is this worth changing?

    params: tuple
        parameters of collision frequency model
    low, high: int
        define range of the uniform distribution
    """
    if np.all(l <= params) and np.all(params < h):
        return 0.0
    return -np.inf
    
def log_likelihood(params, x, y, dielectricfn, wavenum, collisionfn, cutoff=1):
    """
    log likelihood function that is the log of an N-dimensional cut-off
    function with soft sides.

    params (dict): parameters that go into collision rate model
    x: frequency data points corresponding to output data `y`
    y: ELF data points
    dielectricfn: dielectric function, a function of `wavenum` and `freq`
    wavenum: wave number value(s)
    freq: array of frequency values
    collisionfn: function for collision rate, depends on `freq` and `params`
    hyperparams (dict): keyword arguments for the hyperparameters of the
        likelihood function.
    
    returns:
        log likelihood
    """
    if cutoff <= 0:
        raise RuntimeError("cutoff must be positive and nonzero")

    residual = residual_fn(x,
                           y,
                           dielectricfn,
                           wavenum,
                           collisionfn
                          )
        
    loglik = -np.max((residual(params) / (np.sqrt(2) * cutoff))**2)
    
    return loglik

def log_posterior_fn(x, y, dielectricfn, wavenum, collisionfn, likhyperparams):
    """
    log posterior pdf.
    
    x: frequency data points corresponding to output data `y`
    y: ELF data points
    dielectricfn: dielectric function, a function of `wavenum` and `freq`
    wavenum: wave number value(s)
    freq: array of frequency values
    collisionfn: function for collision rate, depends on `freq` and `params`
    likhyperparams (dict): keyword arguments for the hyperparameters of the
        likelihood function.
    
    returns:
        log posterior function that only depends on params of collision rate
        model.
    """
    def log_posterior(params):
        """
        params (dict): parameters that go into collision rate model
        """
        prior = log_prior(tuple(params.values()))
        lik = log_likelihood(params,
                             x, 
                             y, 
                             dielectricfn, 
                             wavenum, 
                             collisionfn, 
                             **likhyperparams
                            )
        
        if not (np.isfinite(prior) and np.isfinite(lik)):
            return -np.inf
            
        return prior + lik

    return log_posterior
```

```{code-cell} ipython3
log_posterior = log_posterior_fn(freq_data_trim / AtomicUnits.energy,
                                 elf_data,
                                 Mermin(ElectronGas(t, d, dos_fn)),
                                 wavenum_val * AtomicUnits.length,
                                 collisionrate,
                                 cutoff = 0.2
                                )
```

## Initial state of MCMC

We will use the results from the optimization to initialize the Markov chains.

```{code-cell} ipython3
rng = np.random.default_rng()

numchains = 12
initstate = tuple(optresult.x.values()) + rng.standard_normal(size=(numchains, len(optresult.x)))
initstate
```

I'm not sure how to proceed with dictionaries... Could try to use JAX Pytree, see
<https://gist.github.com/dfm/3e637d60d452e1306b2c4077e33f103a>
We would have to import jax, but I think we might move in this direction anyways..

```{code-cell} ipython3

```
