---
jupytext:
  formats: ipynb,md:myst
  text_representation:
    extension: .md
    format_name: myst
    format_version: 0.13
    jupytext_version: 1.16.0
kernelspec:
  display_name: Python 3 (ipykernel)
  language: python
  name: python3
---

# Optimize collision rate model for known Average Atom collision rate data, using different residual functions

We use collision rate data from an average atom model to produce Mermin ELF data.
We then try to fit a Mermin ELF model using our collision rate model to the data.

This is very similar to `4.1-twh-optimize-known-AAcollisions.txt`, but now we want to examine the effects that
different residual functions (or different loss functions) have on the result. We also examine the optimization 
using data with additive Gaussian noise. 

```{code-cell} ipython3
---
jupyter:
  source_hidden: true
---
# Load the "autoreload" extension so that code can change
%load_ext autoreload

# always reload modules so that as you change code in src, it gets loaded
%autoreload 2
```

```{code-cell} ipython3
---
jupyter:
  source_hidden: true
---
import numpy as np
rng = np.random.default_rng()
from scipy import optimize
import matplotlib.pyplot as plt
from functools import partial

import emcee 
from multiprocessing import Pool

from uegdielectric import ElectronGas
from uegdielectric.dielectric import Mermin

from src.inference.collision_models import collision_activate_decay
from src.inference.mcmc_inference import unique_hdf5_group
from src.utilities import collrateimag, AtomicUnits, elec_loss_fn

import warnings
warnings.filterwarnings('ignore')
```

# Define collision rate model

```{code-cell} ipython3
---
jupyter:
  source_hidden: true
---
# define our collision rate function
def collisionrate(freq, params):
    # real part
    recollision = collision_activate_decay(freq, *params)
    # imaginary part
    imcollision = collrateimag(recollision)

    return recollision + 1j * imcollision
```

## Define the plotting function

```{code-cell} ipython3
---
jupyter:
  source_hidden: true
---
def make_plots(collisionrate_params, elf_data):
    # plot characterstics depend on if we plot the last subplot
    numplots = 3 if np.all(elf_data > 0) else 2
    figsize = (6, 10)
    if numplots == 3:
        figsize = (6, 15)
    fig, axs = plt.subplots(numplots, 1, figsize=figsize, sharex=True)
    
    # collision frequency
    # original
    truecollisions = true_collrate_fn(freq_data_trim / AtomicUnits.energy)
    axs[0].semilogx(freq_data_trim,
                    truecollisions.real,
                    c="C3",
                    label="Avg. Atom")
    axs[0].plot(freq_data_trim, truecollisions.imag, c="C3", ls="--")
    
    # optimized
    optcollisions = collisionrate(freq_data_trim / AtomicUnits.energy,
                                  collisionrate_params)
    axs[0].plot(freq_data_trim, optcollisions.real, c="C0", label="opt.")
    axs[0].plot(freq_data_trim, optcollisions.imag, c="C0", ls="--")
    
    axs[0].set_ylabel("collision frequency [au]")

    # ELF
    # orignal
    axs[1].semilogx(freq_data_trim, elf_data, c="C3", label="Avg. Atom")
    opt_elf = elec_loss_fn(Mermin(ElectronGas(t, d, dos_fn)),
                           wavenum_val * AtomicUnits.length,
                           freq_data_trim / AtomicUnits.energy,
                           lambda x: collisionrate(x, collisionrate_params)
                          )
    # optimized
    axs[1].plot(freq_data_trim, opt_elf, c="C0", ls='-.', label="opt.")
    axs[1].set_ylabel("ELF [au]")
    
    # optimize - loglog plot
    # check that elf_data is strictly positive
    if numplots == 3:
        axs[2].loglog(freq_data_trim, elf_data, c="C3", label="Avg. Atom")
        axs[2].plot(freq_data_trim, opt_elf, c="C0", ls='-.', label="opt.")
        axs[2].set_ylabel("ELF [au]")
        axs[2].set_xlabel(r"$\hbar \omega$ [eV]")
        axs[2].set_ylim(1e-6)
    else:
        axs[1].set_xlabel(r"$\hbar \omega$ [eV]")

    axs[0].legend()

    return fig, axs
```

## Define a function to perform the repeated analysis

```{code-cell} ipython3
---
jupyter:
  source_hidden: true
---
def analysis(freq, ydata, dielectricfn, wavenum, collisionfn, initparams, residualtype="abs"):
    """
    Helper function that performs the main analysis of this notebook,
    which is repeated multiple times with slightly different inputs.

    freq: frequency data points corresponding to output data `y`
    ydata: ELF data points
    dielectricfn: dielectric function, a function of `wavenum` and `freq`
    wavenum: wave number value(s)
    collisionfn: function for collision rate, depends on `freq` and the
        parameters `params` we want to optimize
    residualtype: "abs" for absolute residual or "rel" for relative residual.
    initparams: initial parameters for optimization
    """
    weight = 1 if residualtype == "abs" else ydata
    
    # setup
    residual = partial(residual_fn,
                       freq,
                       ydata,
                       dielectricfn,
                       wavenum,
                       collisionfn,
                       weight=weight
                      )
    
    # optimization results
    optresult = optimize.least_squares(residual, initparams, max_nfev=150)

    # print difference between the model with optimized parameters
    # and the data
    elf_calc = elec_loss_fn(dielectricfn,
                            wavenum,
                            freq,
                            lambda x: collisionfn(x, optresult.x)
                           )
    print(f"2-norm of absolute difference: {np.linalg.norm(ydata - elf_calc)}")
    print(f"2-norm of relative difference: {np.linalg.norm((ydata - elf_calc)/ydata)}")

    # plot the results
    _ = make_plots(optresult.x, ydata)
    
    return optresult
```

# Get the data

```{code-cell} ipython3
---
jupyter:
  source_hidden: true
---
datafile = "../../data/external/Al-1 _vwf.txt"
# just copying from the data file
# temperature
teV = 1
t = teV / AtomicUnits.energy

# density
d_ang = 0.18071 # 1/[angstroms]**3
d = d_ang * AtomicUnits.length**3

datadump = np.loadtxt(datafile, skiprows=9, usecols=[0, 5, 6, 9], unpack=True)
freq_data = datadump[0] # [eV]
print(f"length of data = {len(freq_data)}")
collrate_data = datadump[1] + 1j * datadump[2]
dos_data = datadump[3]

# function for true collision rate
true_collrate_fn = lambda x : np.interp(x, freq_data / AtomicUnits.energy, collrate_data)
# function for DOS ratio
dos_fn = lambda x : np.interp(x, freq_data / AtomicUnits.energy, dos_data)

# Wavenumber is independent of data -- can pick whatever we want to create our ELF data
wavenum_val = 0.7 / AtomicUnits.length # 1/[angstrom]
```

### Create ELF data with collision rate data, and an noisy ELF data set

We will also trim down the number of data points.

```{code-cell} ipython3
---
jupyter:
  source_hidden: true
---
# Reduce the amount of data we are considering
freq_data_trim = freq_data[::8]
# true ELF data
elf_data = elec_loss_fn(Mermin(ElectronGas(t, d, dos_fn)),
                        wavenum_val * AtomicUnits.length,
                        freq_data_trim / AtomicUnits.energy,
                        true_collrate_fn
                       )
print(elf_data.shape)

# noisy ELF data: additive Gaussian noise with a standard deviation
# set to 1% of the max value
elf_data_noise = elf_data + 0.01 * np.max(elf_data) * rng.standard_normal(len(elf_data)) 
```

### plot the collision rate data

```{code-cell} ipython3
---
jupyter:
  source_hidden: true
---
plt.semilogx(freq_data_trim, true_collrate_fn(freq_data_trim / AtomicUnits.energy).real, label="real")
plt.plot(freq_data_trim, true_collrate_fn(freq_data_trim / AtomicUnits.energy).imag, label="imag.")
plt.xlabel(r"$\omega$ [eV]")
plt.ylabel("collision frequency [au]")
plt.legend()
```

# Define a residual function for optimizing the parameters
We are ultimately performing a nonlinear least squares optimization. The loss function in this case is
$$ L(\theta) = \min_\theta \|r(\theta)\|_2^2,$$
where the $i^\mathrm{th}$ component of the vector residual is $r_i(\theta) = y_i - f(x_i; \theta)$, and
$y_i$ is the data and $f(x_i; \theta)$ is the model evaluated at the point $x_i$ with parameters $\theta$
we want to optimize.

We also want to consider a residual function that considers the _relative_ difference between the model and
the data, $r'_i(\theta) = (y_i - f(x_i; \theta))/y_i$. This can be useful if the data spans different orders
of magnitude and we want to treat each point equally (for example, when using the absolute residual, by default larger values have more importance
simply because they are larger).

```{code-cell} ipython3
def residual_fn(x, ydata, dielectricfn, wavenum, collisionfn, params, weight=1):
    """
    weighted residual function
    
    x: frequency data points corresponding to output data `y`
    ydata: ELF data points
    dielectricfn: dielectric function, a function of `wavenum` and `freq`
    wavenum: wave number value(s)
    collisionfn: function for collision rate, depends on `freq` and the
        parameters `params` we want to optimize
    params (tuple): parameters that go into collision rate model `collisionfn`
    weight: scalar or array_like consistent with `x` and `y`
        weights the residual function, useful for emphasizing portions
        of the data that we may have more confidence in (i.e. low noise),
        for example. Defualt returns the absolute (typical) least squares
        residual.
        
    returns:
        residual of the model with respect to the data `y`
    """
    elf_calc = elec_loss_fn(dielectricfn,
                            wavenum,
                            x,
                            lambda x: collisionfn(x, params))
    return (ydata - elf_calc) / weight
```

# Optimize to get parameters

```{code-cell} ipython3
# initial parameter guesses
initparams = (0, 1, 0, 1, 1.5, 0, 10)
```

## 1. absolute residual

```{code-cell} ipython3
opt = analysis(freq_data_trim / AtomicUnits.energy,
               elf_data,
               Mermin(ElectronGas(t, d, dos_fn)),
               wavenum_val * AtomicUnits.length,
               collisionrate,
               initparams,
               residualtype="abs"
              )
```

## 2. Relative residual

```{code-cell} ipython3
opt = analysis(freq_data_trim / AtomicUnits.energy,
               elf_data,
               Mermin(ElectronGas(t, d, dos_fn)),
               wavenum_val * AtomicUnits.length,
               collisionrate,
               initparams,
               residualtype="rel"
              )
```

## 3. Absolute residual with noisy data

```{code-cell} ipython3
opt = analysis(freq_data_trim / AtomicUnits.energy,
               elf_data_noise,
               Mermin(ElectronGas(t, d, dos_fn)),
               wavenum_val * AtomicUnits.length,
               collisionrate,
               initparams,
               residualtype="abs"
              )
```

## 4. Relative residual with noisy data

(a bad idea, since with noisy data we are probably more concerned with fitting the peak rather than the
tails which have a lower signal to noise ratio)

```{code-cell} ipython3
opt = analysis(freq_data_trim / AtomicUnits.energy,
               elf_data_noise,
               Mermin(ElectronGas(t, d, dos_fn)),
               wavenum_val * AtomicUnits.length,
               collisionrate,
               initparams,
               residualtype="rel"
              )
```

```{code-cell} ipython3

```
