---
jupytext:
  formats: ipynb,md:myst
  text_representation:
    extension: .md
    format_name: myst
    format_version: 0.13
    jupytext_version: 1.16.0
kernelspec:
  display_name: Python 3 (ipykernel)
  language: python
  name: python3
---

# Bayesian Inference with Markov Chain Monte Carlo: Ideal Dataset

This notebook is roughly identical with `5.0-twh-....ipynb` except that the ELF data for this notebook is generated from our collision model _fit to Average Atom collision rate data_. In other words, the collision rate we are trying to find is exactly representable by our model, so we are testing the limits of the inversion process.

```{code-cell} ipython3
# Load the "autoreload" extension so that code can change
%load_ext autoreload

# always reload modules so that as you change code in src, it gets loaded
%autoreload 2
```

```{code-cell} ipython3
import numpy as np
import matplotlib.pyplot as plt
from scipy import optimize
from functools import partial
from datetime import datetime

import emcee 
from multiprocessing import Pool
from uegdielectric import ElectronGas
from uegdielectric.dielectric import Mermin

from src.inference.collision_models import collision_activate_decay
from src.inference.mcmc_inference import inference_loop, flat_mcmc_samples
from src.utilities import kramerskronig, AtomicUnits, elec_loss_fn
import src.inference.probability_models as prob

import warnings
warnings.filterwarnings('ignore')
```

# Get the data

```{code-cell} ipython3
datafile = "../../data/external/Al-1 _vwf.txt"
# just copying from the data file
# temperature
teV = 1
t = teV / AtomicUnits.energy

# density
d_ang = 0.18071 # 1/[angstroms]**3
d = d_ang * AtomicUnits.length**3

datadump = np.loadtxt(datafile, skiprows=9, usecols=[0, 5, 6, 9], unpack=True)
orig_freq_data = datadump[0] # [eV]
print(f"length of original data = {len(orig_freq_data)}")
AA_collrate_data = datadump[1] + 1j * datadump[2]
dos_data = datadump[3]

# function for Average Atom collision rate
AA_collrate_fn = lambda x : np.interp(x, orig_freq_data / AtomicUnits.energy, AA_collrate_data)
# function for DOS ratio
dos_fn = lambda x : np.interp(x, orig_freq_data / AtomicUnits.energy, dos_data)

# create a new, more regular frequency grid that what exists in the data file
freq_data = np.geomspace(orig_freq_data[0], orig_freq_data[-1], 99) # [eV]
# Wavenumber is independent of data -- can pick whatever we want to create our ELF data
wavenum = 1.55 # 1/[angstrom]
```

# Define collision rate model

```{code-cell} ipython3
# define our collision rate function
def collisionrate(freq, params):
    # real part
    recollision = collision_activate_decay(freq, *params)
    # imaginary part
    imcollision = kramerskronig(freq, recollision)

    return recollision + 1j * imcollision
```

# Define the ELF model

using ther Mermin dielectric function and the `collisionrate` function

```{code-cell} ipython3
dielectric = Mermin(ElectronGas(t, d, dos_fn))

def elfmodel(freq, params):
    return elec_loss_fn(
        dielectric,
        wavenum * AtomicUnits.length,
        freq,
        lambda x: collisionrate(x, params)
        )
```

## Fit our collision rate model to AA collision rate

Note that we are only fitting to the real part of the data.
The imaginary part is found from Kramers-Kronig transformation.

```{code-cell} ipython3
# fit to data
popt_AAcoll, pcov = optimize.curve_fit(
    collision_activate_decay, 
    freq_data / AtomicUnits.energy,
    AA_collrate_fn(freq_data / AtomicUnits.energy).real,
    (1,1,1,1),
    bounds=(0, np.inf)
)
print(popt_AAcoll)

# plot to compare
plt.semilogx(freq_data, (AAcoll := AA_collrate_fn(freq_data / AtomicUnits.energy)).real, c="C3", label="AA")
plt.plot(freq_data, AAcoll.imag, c="C3", ls="--")
plt.plot(freq_data, (modelcoll := collisionrate(freq_data / AtomicUnits.energy, popt_AAcoll)).real, c="C0", label="opt")
plt.plot(freq_data, modelcoll.imag, c="C0", ls="--")
plt.xlabel(r"$\hbar\omega$ [eV]")
plt.ylabel("collision rate [au]")
plt.legend()
```

### Create ELF data with our collision rate  model using parameters fit to mimic the average atom collision rate data

```{code-cell} ipython3
# true ELF data
elf_data = elfmodel(freq_data / AtomicUnits.energy, popt_AAcoll)
print(f"shape of ELF data = {elf_data.shape}")
```

# Define residual function for ELF data

```{code-cell} ipython3
# setup
def residual(params):
    return prob.residual(
        elfmodel, freq_data / AtomicUnits.energy, elf_data, params, type="rel"
    )
# initial par
# initial parameter guesses
initparams = (1, 1, 1, 1)

# optimization results
optresult = optimize.least_squares(residual, initparams, bounds=(0, np.inf), max_nfev=150)
```

```{code-cell} ipython3
optresult
```

```{code-cell} ipython3
# original
plt.semilogx(freq_data, collisionrate(freq_data / AtomicUnits.energy, popt_AAcoll).real, c="C3", label="true")
# optimized
plt.plot(freq_data, collisionrate(freq_data / AtomicUnits.energy, optresult.x).real, c="C0", label="opt.", ls="--")
plt.xlabel(r"$\hbar\omega$ [eV]")
plt.ylabel("collision rate [au]")
plt.legend()
```

```{code-cell} ipython3
plt.loglog(freq_data, elf_data, c="C3", label="true")
opt_elf = elfmodel(freq_data / AtomicUnits.energy, optresult.x)
plt.plot(freq_data, opt_elf, c="C0", ls='-.', label="opt.")
plt.ylabel("ELF [au]")
plt.xlabel(r"$\hbar \omega$ [eV]")
plt.ylim(1e-6)
plt.legend()
```

# Perform MCMC

Define a (log) posterior distribution that only depends on the parameters of the collision rate model

```{code-cell} ipython3
lik_cutoff = 0.05
prior_lims = [
    [0, 5],
    [0, 5],
    [0, 100],
    [0, 100]
]

logprior = prob.UniformLogPrior(prior_lims)
loglikelihood = prob.SoftCutoffLogLikelihood(
    elf_data,
    freq_data / AtomicUnits.energy,
    elfmodel,
    lik_cutoff,
    residualtype="rel"
)
logposterior = prob.LogPosterior(logprior, loglikelihood)
logposterior(optresult.x)
```

## Run the MCMC sampler

We will use the results from the optimization to initialize the Markov chains.

```{code-cell} ipython3
samplesfile = "../../data/mcmc/mcmc_modeldata"
dataset = "mcmc samples - model data - rel. residual - 4 params"
```

```{code-cell} ipython3
runinfo = {
    "date" : datetime.today().strftime('%a %d %b %Y, %I:%M%p'),
    "input data info" : f"""Data generated using collision rate model
        fit to average atom data from file {datafile}. Uses updated
        Kramers-Kronig transform for imaginary part of collisoin rate.""",
    "input data temperature [eV]" : teV,
    "input data density [1/angstrom^3]" : d_ang,
    "input data wavenumber [1/angstrom]" : wavenum,
    "collision rate model" : "collision_activate_decay, 4 parameters",
    "likelihood function" : f"Soft (expenonential) cutoff with a cutoff value of {lik_cutoff}",
    "residual" : "relative",
    "prior distribution function" : f"Uniform distribution with boundaries ({prior_lims})"
}

# sampler properties
ndim = 4 # number of parameters
numchains = 32
numsamples = 15_000
```

```{code-cell} ipython3
# randomly initialize chains within the boundaries
rng = np.random.default_rng()
initial_state = optresult.x + 1e-4 * rng.random(size=(numchains, ndim))

sampler = inference_loop(initial_state, logposterior, numsamples, samplesfile, dataset, overwrite=True)
```

```{code-cell} ipython3
# # view attributes of dataset
# with h5py.File(samplesfile, "a") as f:
#     print(list(f.keys()))
#     dset = f["mcmc_samples"]
#     for attr in dset.attrs:
#         print(f"{attr} : {dset.attrs[attr]}")
```

# Read in MCMC data

```{code-cell} ipython3
backend = emcee.backends.HDFBackend(samplesfile, name=dataset)
flat_samples = flat_mcmc_samples(backend)
```

# MCMC results

```{code-cell} ipython3
plt.close()
paramnames = (
    "gen. Lorentzian height",
    "gen. Lorentzian power-law",
    "Logistic activate",
    "Logistic gradient"
)
fig, axes = plt.subplots(ndim, figsize=(10,2.5*5), sharex=True)
samples = backend.get_chain()
for i in range(ndim):
    ax = axes[i]
    ax.plot(samples[:,:,i], 'k', alpha=0.3)
    #ax.set_xlim(0, len(samples))
    ax.set_ylabel(f"{paramnames[i]}")
    ax.yaxis.set_label_coords(-0.1, 0.5)

axes[-1].set_xlabel("step number");
```

```{code-cell} ipython3
import corner

fig = corner.corner(flat_samples, labels=paramnames)

# compute empirical mean of samples
mean = np.mean(flat_samples, axis=0)

corner.overplot_lines(fig, mean, linestyle="--", color="C0")
corner.overplot_points(fig, mean[np.newaxis], marker="o", linestyle="--", color="C0")
corner.overplot_lines(fig, popt_AAcoll, color="C3")
corner.overplot_points(fig, popt_AAcoll[np.newaxis], marker="o", color="C3")
```

```{code-cell} ipython3
# randomly pick 100 samples from our MCMC sampling data
inds = rng.integers(len(flat_samples), size=100)

# plot collision function for different parameters from MCMC sampling
for ind in inds:
    sample = flat_samples[ind]
    plt.loglog(freq_data, 
               collisionrate(freq_data / AtomicUnits.energy, sample), 
               "C1", 
                alpha=0.1
              )

# plot true collision frequency
plt.plot(freq_data,
         collisionrate(freq_data / AtomicUnits.energy, popt_AAcoll).real,
         c="k",
         label="true",
         lw=2,
         ls='--'
        )

plt.xlabel(r"$\hbar\omega$ [eV]")
plt.ylabel("collision rate [au]")
# plt.ylim(1e-3)
plt.legend()
# plt.savefig("../../reports/figures/mcmc_modeldata_collisionsamples")
```

```{code-cell} ipython3
eps = Mermin(ElectronGas(t, d, dos_fn))
# plot ELF for different parameters from MCMC sampling
for ind in inds:
    sample = flat_samples[ind]
    plt.semilogx(freq_data,
                 elec_loss_fn(
                     eps,
                     wavenum * AtomicUnits.length,
                     freq_data / AtomicUnits.energy,
                     lambda x: collisionrate(x, sample)
                 ), 
                 "C1", 
                 alpha=0.1)
# plot data
plt.loglog(freq_data, elf_data, c="k", label="true ELF", lw=2, ls='--')

plt.ylabel("ELF [au]")
plt.xlabel(r"$\hbar\omega$ [eV]")
plt.ylim(1e-6)
plt.legend()
# plt.savefig("../../reports/figures/mcmc_modeldata_ELFsamples")
```

```{code-cell} ipython3
eps = Mermin(ElectronGas(t, d, dos_fn))
# plot ELF for different parameters from MCMC sampling
for ind in inds:
    sample = flat_samples[ind]
    plt.plot(freq_data,
             elec_loss_fn(
                 eps,
                 wavenum * AtomicUnits.length,
                 freq_data / AtomicUnits.energy,
                 lambda x: collisionrate(x, sample)
             ), 
             "C1", 
             alpha=0.1)
# plot data
plt.plot(freq_data, elf_data, c="k", label="true ELF", lw=2, ls='--')

plt.ylabel("ELF [au]")
plt.xlabel(r"$\hbar\omega$ [eV]")
plt.xlim(0, 100)
plt.legend()
```

```{code-cell} ipython3

```
