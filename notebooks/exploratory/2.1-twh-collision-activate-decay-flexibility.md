---
jupyter:
  jupytext:
    formats: ipynb,md
    text_representation:
      extension: .md
      format_name: markdown
      format_version: '1.3'
      jupytext_version: 1.16.0
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
---

# Flexibility of collision frequency models

In this notebook, we examine the flexibility of the `born_logpeak_model` model in `src.inference.collision_models` by fitting it directly to examples of known collision rate theories explored in the paper [_Improving dynamic collision frequencies: Impacts on dynamic structure factors and stopping powers in warm dense matter_](https://doi.org/10.1063/5.0143738). In this case, `born_logpeak_model` will consist of an approximate Born collision frequency function with a variable height width fixed to preserves the integral of the true Born collision frequency theory, and a logstic-peak function that has a controllable rise, fall, and activation point.

```python
import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit
from scipy import integrate

from uegdielectric import ElectronGas


from src.inference import collision_models as models
from src.utilities import AtomicUnits, kramerskronig
```

```python
# Load the "autoreload" extension so that code can change
%load_ext autoreload

# Always reload modules so that as you change code in src, it gets loaded
%autoreload 2
```

```python
def apprx_born_variable_width(freq, height, width):
    return height / (1 + (freq / width)**(3/2))
    
def apprx_born_integral_preserving(born_integral_fn, *args):
    born_integral = born_integral_fn(*args)
    def apprx_born_fn(freq, height):
        width = 3 * np.sqrt(3) * born_integral / height / (4 * np.pi)
        return apprx_born_variable_width(freq, height, width)
    return apprx_born_fn

def screeningq(electrons):
    fermi_energy = 0.5 * (3 * np.pi**2 * electrons.density)**(2 / 3)
    effective_temp = np.maximum(electrons.temperature, fermi_energy)
    return np.sqrt(4 * np.pi * electrons.density / effective_temp)

def RPAimag(wavenum, freq, electrons):
    a2 = (2 * freq - wavenum**2)**2 / (2 * wavenum)**2
    b2 = (2 * freq + wavenum**2)**2 / (2 * wavenum)**2

    numer = 1 + np.exp((electrons.chemicalpot - a2 / 2) / electrons.temperature)
    denom = 1 + np.exp((electrons.chemicalpot - b2 / 2) / electrons.temperature)

    return 2 * electrons.temperature / wavenum**3 * np.log(numer / denom)

def realborncollfreq_screening(freq, electrons, Z):
    qs = screeningq(electrons)
    def integrand(wavenum):
        return wavenum**6 / (wavenum**2 + qs**2)**2 * RPAimag(wavenum, freq, electrons)
    q = np.geomspace(1e-6, 1e3, 2000)
    
    integral = integrate.trapezoid(integrand(q), q)
    return 2 * Z * integral / (3 * np.pi * freq)

def pintegral_screening(electrons):
    qs = screeningq(electrons)
    def integrand(p):
        fermi = 1 / (1 + np.exp((p**2 / 2 - electrons.chemicalpot) / electrons.temperature))
        screeningterm = (
            np.pi * np.arctan(2 * p / qs) - np.pi * 2 * p * qs / (2 * (4 * p**2 + qs**2))
        )
        return p * fermi * screeningterm

    p1 = np.geomspace(1e-4, electrons.chemicalpot, 1000, endpoint=False)
    p2 = np.geomspace(electrons.chemicalpot, np.sqrt(20 * electrons.temperature + 2 * np.abs(electrons.chemicalpot)), 1000)
    p = np.concatenate((p1, p2))
    return integrate.trapezoid(integrand(p), p)

def born_integral_screening(electrons, Z):
    return 4 * Z / (3 * np.pi) * pintegral_screening(electrons)

def create_collision_model1(electrons, Z):
    born_term = apprx_born_integral_preserving(born_integral_screening, electrons, Z)
    def model1(freq, v0, v1, alpha, wa, p1):
        logistic_term = v1 / (1 + np.exp(-alpha * (freq - wa)) + (freq / wa)**p1)
        return born_term(freq, v0) + logistic_term
    return model1
```

# Read in data for the collision rate theories we want to directly fit to

The data file includes the indepedent variable as the first column and then pairs of adjacent columns that correspond to the real and imaginary parts of the collision rate theories for the material considered (which material is not important). The last column is the density of states of the material and is not needed here.

```python
datafile = "../../data/external/Al-1 _vwf.txt"

# last column of data is not needed for this
freqev, Tmat, Tmatim, Tplus, Tplusim, KG, KGim = np.loadtxt(datafile, skiprows=9, usecols=[0, 3, 4, 5, 6, 7, 8], unpack=True)
# limit the frequency grid to be between 0.1 and 500 eV
gridtrunc = (0.1 < freqev) & (freqev < 1e3)
freqev = freqev[gridtrunc]
Tmat = Tmat[gridtrunc]
Tplus = Tplus[gridtrunc]
KG = KG[gridtrunc]
Tmatim = Tmatim[gridtrunc]
Tplusim = Tplusim[gridtrunc]
KGim = KGim[gridtrunc]

# convert grid to au
freq = freqev / AtomicUnits.energy

print(f"shape of data = {freq.shape}")
```

```python
# temperature
teV = 1
t = teV / AtomicUnits.energy

# density
d_ang = 0.18071 # 1/[angstroms]**3
d = d_ang * AtomicUnits.length**3

# charge state
Z = 3

electrons = ElectronGas(t, d)
print(f"inverse screening length = {screeningq(electrons)}")
print(f"chemical potential = {electrons.chemicalpot}")
```

## Create Born collision frequency data

```python
born = np.zeros_like(freq)
for i in range(len(freq)):
    born[i] = realborncollfreq_screening(freq[i], electrons, Z)
```

## define first collision frequency model

```python
model1 = create_collision_model1(electrons, Z)
```

# Plot the results

The solid color lines are for the original data while the matching-colored dashed lines are for the model with optimized parameters.

## All the parameters

```python
# save the optimized parameters for inspection
# plot the real part only and our fitted model first
names = ["Born", "T-matrix", "T-matrix + inel.", "KG"]
collisionfreqs = [born, Tmat, Tplus, KG]
for colldata, name in zip(collisionfreqs, names):
    # fit the model to the data
    # sigma is the data so we consider the relativer residual in the fit: (ydata - model) / ydata
    popt, pcov = curve_fit(model1, freq, colldata, p0=(1, 1, 1, 1, 1), sigma=colldata, bounds=(0, np.inf))
    print(name)
    print(f"optimized parameters: {popt}")
    print(f"condition number of cov. matrix: {np.linalg.cond(pcov)}")
    # plot the data
    p = plt.loglog(freqev, colldata, label=name)
    # plot the model with optimized parameters
    plt.plot(freqev, model1(freq, *popt), color=p[-1].get_color(), ls="--")

plt.ylim(1e-3)
plt.legend()
```

## Imaginary parts

```python
names = ["Born", "T-matrix", "T-matrix + inel.", "KG"]
collisionfreqs = [born, Tmat, Tplus, KG]
imagcollfreqs = [Tmatim, Tplusim, KGim]
i = 0
for colldata, name in zip(collisionfreqs, names):
    # fit the model to the data
    # sigma is the data so we consider the relativer residual in the fit: (ydata - model) / ydata
    popt, pcov = curve_fit(model1, freq, colldata, p0=(1, 1, 1, 1, 1), sigma=colldata, bounds=(0, np.inf))
    # plot the model with optimized parameters
    # p = plt.semilogx(freqev, model1(freq, *popt), )
    imag = kramerskronig(freq, lambda x: model1(x, *popt))
    p = plt.semilogx(freqev, imag,  label=f"Im({name})", ls="--")
    if i > 0:
        plt.plot(freqev, imagcollfreqs[i - 1], color=p[-1].get_color())
    i += 1

plt.legend()
```

```python

```
